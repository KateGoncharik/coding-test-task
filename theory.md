# Теория

Так как мы изначально задали i < arr.length, при этом таймер свою функцию будет вызывать только по истечению срока - в переменной i на момент взова будет финальное значение из цикла - 4.
Получить значение arr[i] в данном случае не удастся, ведь там нет элемента по этому индексу.
Вывод будет таким:
Bad: undefined и повторится это 4 раза, т.к. на каждой итерации мы ставили в очередь таймер.

Но если мы хотим получить следующий вывод: Bad: 10, Bad: 12, Good: 15, Good: 21
Нам надо как-то сохранить i на каждой итерации в текущем состоянии. Чтобы i было 0,1,2,3, а не 4,4,4,4.

* 1 Мы копируем i в локальную переменную и через замыкание получаем её значение.
* 2 Вместо arr[i] используем arr[localI]

```

const arr = [10,12,15,21];

for (var i = 0; i< arr.length; i++) {
const localI = i; // * 1
    setTimeout(function() {    
    console.log(arr[localI] > 13 ? `Good: ${arr[localI]}`: `Bad: ${arr[localI]}`) // *2 
}, 3000)

}

```
